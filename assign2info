extract lcloud registers separates all of the parameters that were packed together with create lcloud registers

operating system uses the disk drive and gives it operations. have to send it a message that turns it on because otherwise it cannot communicate. use operations to turn it on, aka LC_POWER_ON.  operations are just commands to send to the device. device probe returns all available devices (but there is only one: the hard drive). transfer (xfer) says you have a block of 256 bytes and it sends it to the device, and you address it by a sector and a block and a device id and it will take the 256 bytes and it will write and take a copy of those bytes (including location) right into the device (the copy via buffer). it gets handed over with the io bus call. buffer is always 256 bytes, period. for operations like power on, pass in a null buffer.

when we call open, we hand back a file handle. the file handle is just a number that only means something to your own code. it is a way for you to map the file.  the number can be constant for this assignment because there is only one file. path name is never used again after open. in open, you are setting up a structure that gets fed information about the file, and the handle gets returned. get the device id from the device probe, see more info on the slides (this may not be used in open, just heard it said). the structure is essentially a two-dimensional array (becomes three dimensional when there is more than one device). if the file does not exist, it is created with length 0 bytes. it only gets a length if a write occurs. simplifying assumption - never use any block for more than one file. you are going to allocate a block and keep doing writes until it fills up, then pick another one and fill that one up. when you do the power on, you are going to create a two-dimensional array that says which blocks you use. when you need a new block, you search the two-dimensional array and check which are unused (1 if used 0 if not). two-dimensional array can be global in this assignment due to the fixed size. array[10][64], aka 10 sectors with 64 blocks each. size of block is 256 bytes. create a local variable in your write function which is your transfer buffer with 256 bytes that you pass into the io bus (if the size is less than 256 bytes, do a memcopy into your local 256 byte buffer). the device is expected a buffer of 256 bytes, if it is something other than 256 bytes, you will seg fault. you are keeping track of the length of the file and the position of the read-write head (which eventually ends up at the end of the file after the read/write is complete). read/write head is the same head. until you do a seek, the head will always be at the far right. position and size will always be the same until seek gets involved. if the write is under 256 bytes, partially fill a block. the write after that will fill up the rest of that block and then continue in a brand new block. obviously, if the write is less than 256 bytes, you have to fill the buffer with 0s where there is no relevant information so that the buffer is still 256 bytes. three cases for writes, one block writes, partial block writes, and multi-block writes. you can have up to 256 individual writes in a single block if necessary. check out buffer splicing. file length % 256 is the amount of space left in a partially written block. lcwrite can take in as many bytes as necessary, it's the xfer part that has to be broken down into 256 bytes per write. use your own read function to avoid having to duplicate reads inside your write code. use helper functions like put_block and get_block where you pass device id, sector, block, and buffer and does all of the io bus stuff for you without having to do it in your main functions. look at the workload and check out what operations are occurring. two data structures: one for file one for the device. the one for the device is a two-dimensional array with sectors and blocks, basically indicates which blocks are used using a 1 or a 0. the file structure must have the filename (aka path), file handle, position, length, and the locations that it is located in (sector and block). If there were more than one device, you would also keep track of the device id. for more detail, look at the slide they are on. for the file system structure, you need to have 40 blocks, because 4096 bytes takes up 40 blocks. 

